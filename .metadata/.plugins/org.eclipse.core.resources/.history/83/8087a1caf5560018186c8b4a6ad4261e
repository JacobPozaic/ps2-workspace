#ifndef THREAD_H_
#define THREAD_H_

/*
 * NOTE THAT THIS IS FOR EE THREADS
 *
int status; // 0x00
void *func; // 0x04
void *stack; // 0x08
int stack_size; // 0x0C
void *gp_reg; // 0x10 general purpose register?
int initial_priority; // 0x14
int current_priority; // 0x18
u32 attr; // 0x1C
u32 option; // 0x20 Do not use - officially documented to not work.
*/

/*
//Alarm value is in H-SYNC ticks.
s32  SetAlarm(u16 time, void (*callback)(s32 alarm_id, u16 time, void *common), void *common);
s32  _SetAlarm(u16 time, void (*callback)(s32 alarm_id, u16 time, void *common), void *common);
s32  ReleaseAlarm(s32 alarm_id);
s32  _ReleaseAlarm(s32 alarm_id);

s32  _iEnableIntc(s32 cause);
s32  _iDisableIntc(s32 cause);
s32  _iEnableDmac(s32 channel);
s32  _iDisableDmac(s32 channel);
s32  iSetAlarm(u16 time, void (*callback)(s32 alarm_id, u16 time, void *common), void *common);
s32  _iSetAlarm(u16 time, void (*callback)(s32 alarm_id, u16 time, void *common), void *common);
s32  iReleaseAlarm(s32 alarm_id);
s32  _iReleaseAlarm(s32 alarm_id);
s32	 CreateThread(ee_thread_t *thread);
s32	 DeleteThread(s32 thread_id);
s32	 StartThread(s32 thread_id, void *args);
void ExitThread(void);
void ExitDeleteThread(void);
s32  TerminateThread(s32 thread_id);
s32  iTerminateThread(s32 thread_id);
// void DisableDispatchThread(void);	// not supported
// void EnableDispatchThread(void);		// not supported
s32  ChangeThreadPriority(s32 thread_id, s32 priority);
s32  iChangeThreadPriority(s32 thread_id, s32 priority);
s32  RotateThreadReadyQueue(s32 priority);
s32  _iRotateThreadReadyQueue(s32 priority);
s32  ReleaseWaitThread(s32 thread_id);
s32  iReleaseWaitThread(s32 thread_id);
s32	 GetThreadId(void);
s32  _iGetThreadId(void);		//This is used for a hack by SCE, to work around the iWakeupThread design flaw
s32  ReferThreadStatus(s32 thread_id, ee_thread_status_t *info);
s32  iReferThreadStatus(s32 thread_id, ee_thread_status_t *info);
s32  SleepThread(void);
s32	 WakeupThread(s32 thread_id);
s32	 _iWakeupThread(s32 thread_id);
s32	 CancelWakeupThread(s32 thread_id);
s32	 iCancelWakeupThread(s32 thread_id);
s32	 SuspendThread(s32 thread_id);
s32	 _iSuspendThread(s32 thread_id);
s32	 ResumeThread(s32 thread_id);
s32	 iResumeThread(s32 thread_id);

u8 RFU059(void);

void * SetupThread(void * gp, void * stack, s32 stack_size, void * args, void * root_func);
void SetupHeap(void * heap_start, s32 heap_size);
void *EndOfHeap(void);

s32	 CreateSema(ee_sema_t *sema);
s32	 DeleteSema(s32 sema_id);
s32	 SignalSema(s32 sema_id);
s32	 iSignalSema(s32 sema_id);
s32	 WaitSema(s32 sema_id);
s32	 PollSema(s32 sema_id);
s32	 iPollSema(s32 sema_id);
s32	 ReferSemaStatus(s32 sema_id, ee_sema_t *sema);
s32	 iReferSemaStatus(s32 sema_id, ee_sema_t *sema);
s32	iDeleteSema(s32 sema_id);
 */

// TODO: find out how aligned works, some thread stacks aligned 64?
static char default_stack[16*1024] __attribute__((aligned(16)));
static void * default_gp_reg;
static int default_priority = 0;
static u32 default_attr = 0x02000000;
static u32 default_option = 0;

s32 createThread(void * function);
s32 createThread(void * function, int priority);
s32 createThread(void * function, char stack[], int priority);
s32 createThread(void * function, char stack[], void * gp_register, int priority, u32 attr, u32 option);

s32 startThread(t_id);
s32 startThread(t_id, void * args);

void interuptThread(int t_id);
void join(int t_id);
void wait(int t_id);

static struct thread {
	ee_thread_t * thread;
	string name;

	priority
};

#endif /* THREAD_H_ */
