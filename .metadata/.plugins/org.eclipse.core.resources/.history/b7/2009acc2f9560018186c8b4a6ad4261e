#include <kernel.h>
#include <tamtypes.h>
#include <string.h>

#include <Thread.h>

s32 getCurrentThread() {
	return GetThreadId();
}

string getThreadName(s32 t_id) {
	return 0; //TODO: implement
}

int getThreadStatus(s32 t_id) {
	return 0; //TODO: implement
}

void setThreadPriority(s32 t_id, s32 priority) {
	ChangeThreadPriority(t_id, priority); // returns an s32 (t_id?)
}
int getThreadStackSize(s32 t_id);
char * getStackContents(s32 t_id);

s32 createThread(void * function) {
	return createThread(function, default_stack, default_gp_reg, default_priority, default_attr, default_option);
}

s32 createThread(void * function, int priority) {
	return createThread(function, default_stack, default_gp_reg, priority, default_attr, default_option);
}

s32 createThread(void * function, char stack[], int priority) {
	return createThread(function, stack, default_gp_reg, priority, default_attr, default_option);
}

s32 createThread(void * function, char stack[], void * gp_register, int priority, u32 attr, u32 option) {
	ee_thread_t t;

	t.func = function;
	t.stack = stack;
	t.stack_size = sizeof(stack);
	t.gp_reg = gp_register;
	t.initial_priority = priority;
	t.attr = attr;
	t.option = option;

	//TODO: store the t_id & ee_thread_t in a table, and if successfully created then return t_id.
	//maybe not a bad idea to hide t_id under another name so direct thread operations cant mess with it.
	return CreateThread(&t);
}

s32 deleteThread(s32 t_id) {
	DeleteThread(t_id);
}

s32 startThread(s32 t_id) {
	return StartThread(t_id, 0);
}

s32 startThread(s32 t_id, void * args) {
	return StartThread(t_id, args);
}

void interuptThread(s32 t_id) {
	// TODO: implement
}

void join(s32 t_id) {
	//TODO: implement
}

void wait(s32 t_id) {
	//TODO: implement
}
