#ifndef THREAD_H_
#define THREAD_H_

/*
 * NOTE THAT THIS IS FOR EE THREADS
 *
 */

/*
void ExitThread(void);
void ExitDeleteThread(void);
s32  TerminateThread(s32 thread_id);
s32  RotateThreadReadyQueue(s32 priority);
s32  ReleaseWaitThread(s32 thread_id);
s32  ReferThreadStatus(s32 thread_id, ee_thread_status_t *info);
s32  SleepThread(void);
s32	 WakeupThread(s32 thread_id);
s32	 CancelWakeupThread(s32 thread_id);
s32	 SuspendThread(s32 thread_id);
s32	 ResumeThread(s32 thread_id);
 */

// TODO: In non-preemptive once a process start its execution it will terminate only when it ends

static struct {
	ee_thread_t * thread;
	string name;
} thread;

// TODO: find out how aligned works, some thread stacks aligned 64?
static char default_stack[16*1024] __attribute__((aligned(16)));
static void * default_gp_reg;
static s32 default_priority = 50;
static u32 default_attr = 0x02000000;
static u32 default_option = 0;

s32 getCurrentThread(void);
string getThreadName(s32 t_id);
int getThreadStatus(s32 t_id);
s32 getThreadPriority(s32 t_id);
int getThreadStackSize(s32 t_id);
char * getStackContents(s32 t_id);


/*
THS_RUN		0x01
THS_READY	0x02
THS_WAIT	0x04
THS_SUSPEND	0x08
THS_WAITSUSPEND	0x0c
THS_DORMANT	0x10
 */

s32 createThread(void * function);
s32 createThread(void * function, s32 priority);
s32 createThread(void * function, char stack[], s32 priority);
s32 createThread(void * function, char stack[], void * gp_register, s32 priority, u32 attr, u32 option);

s32 deleteThread(s32 t_id);



s32 startThread(s32 t_id);
s32 startThread(s32 t_id, void * args);

void interuptThread(s32 t_id);
void join(s32 t_id);
void wait(s32 t_id);

#endif /* THREAD_H_ */
