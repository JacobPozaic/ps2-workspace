#include <tamtypes.h>

#ifndef THREAD_H_
#define THREAD_H_

/*
 * NOTE: EE threads not IOP
 *
 * TODO: In non-preemptive once a process start its execution it will terminate only when it ends
 */

// TODO: I would like to have some more useful threading functionality.
// TODO: I can make a sort of thread manager with high priority that can suspend/resume or sleep/wakeup to fake stronger scheduling

// TODO: find out how aligned works, some thread stacks aligned 64?
static char default_stack[16*1024] __attribute__((aligned(16)));
static void * default_gp_reg;
static s32 default_priority = 50;
static u32 default_attr = 0x02000000;
static u32 default_option = 0;

/**
 * Returns the t_id of the current thread (the one this line of code resides in when called)
 */
s32 getCurrentThread(void);

/**
 * Returns the status of the thread.
 * TODO: fact check statuses
 *
 * THS_RUN		    0x01    Thread is running
 * THS_READY	    0x02    Thread is ready to run
 * THS_WAIT	        0x04    Thread is waiting
 * THS_SUSPEND	    0x08    Thread has been suspended
 * THS_WAITSUSPEND	0x0c    Thread is waiting and suspended
 * THS_DORMANT	    0x10    Thread is not doing anything
 */
int getThreadStatus(s32 t_id);

s32 getThreadPriority(s32 t_id);

int getThreadStackSize(s32 t_id);

char * getStackContents(s32 t_id);

//----------------------------------------------------------------------------------------------------
// Thread management functions

/**
 * Creates a thread with a given priority, stack, gp register, attr, and option.
 */
s32 createThread(void * function, char stack[], void * gp_register, s32 priority, u32 attr, u32 option);

/**
 * Start the given thread.
 */
s32 startThread(s32 t_id);

/**
 * Start the given thread with arguments.
 * Arguments can be anything, you pass it to your thread, and define them in your thread definition.
 */
s32 startThread(s32 t_id, void * args);

/**
 * Exits the thread this thread.
 * TODO: unsure if this means thread has completed, or release thread so another can be scheduled
 */
void exitThread(void);

/**
 * Exits and deletes this thread.
 * TODO: unsure if this means thread has completed, or release thread so another can be scheduled
 */
void exitDeleteThread(void);

/**
 * Deletes a given thread from memory.  A thread that has finished execution is not deleted.
 */
s32 deleteThread(s32 t_id);

/**
 * Terminates a given thread.
 * TODO: unsure if this means the thread will no longer be scheduled.
 */
s32 terminateThread(s32 thread_id);

//----------------------------------------------------------------------------------------------------
// Thread scheduling functions

/**
 * TODO: I assume this cycles through the threads with state READY for the scheduler, or maybe it does something to the priority?
 */
s32 rotateThreadReadyQueue(s32 priority);

/**
 * Releases a given waiting thread.
 * A thread that is waiting means that it is ready to be scheduled, just not currently executing.
 * TODO: no idea what this actually does, possibly drops a waiting thread, or gives it execution?
 */
s32 releaseWaitThread(s32 thread_id);

/**
 * TODO: honestly have no idea.
 */
s32 referThreadStatus(s32 thread_id, ee_thread_status_t *info);

//----------------------------------------------------------------------------------------------------
// Thread sleep functions

/**
 * Makes the current thread sleep until WakeupThread is called on its t_id.
 */
s32 sleepThread(void);

/**
 * Wakes up a given thread that is sleeping.
 */
s32	wakeupThread(s32 thread_id);

/**
 * Cancels a wake-up call on a given thread.
 *
 * I assume this functions is to cancel a call to WakeupThread, where later during execution of the
 * calling thread it is determined that the other thread should not be woken up, before the calling
 * thread releases its execution slot to the scheduler.
 */
s32	cancelWakeupThread(s32 thread_id);

//----------------------------------------------------------------------------------------------------
// Thread suspension functions
// NOTE: Suspend is often deprecated (although not documented here) as it is prone to deadlocks
// The nature of sleep in PS2's context doesn't seem to add any safer functionality though.

/**
 * Suspends a given thread.
 * A suspended thread is paused and will not be rescheduled or continue executing until it is resumed.
 */
s32	suspendThread(s32 thread_id);

/**
 * Resumes a given suspended thread.
 */
s32	resumeThread(s32 thread_id);

//----------------------------------------------------------------------------------------------------

#endif /* THREAD_H_ */
